---
layout: vimdoc
helpname: 'usr_51'
---
<div id='vimCodeElement'>
<a class="Constant" href="usr_51.html" name="usr_51.txt">usr_51.txt</a>&nbsp;&nbsp;&nbsp;&nbsp;For&nbsp;<span class="Identifier">Vim バージョン 8.2.</span>&nbsp;&nbsp;Last change: 2022 May 14<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VIM USER MANUAL - by Bram Moolenaar<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;プラグインを作る<br>
<br>
<br>
プラグインを使用することで、特定のファイルの種別の設定、構文ハイライトやその他<br>
多くの設定を定義できます。<br>
この章ではVimプラグインでのもっとも共通な部分の書き方について説明します。<br>
<br>
<a class="Identifier" href="usr_51.html#51.1">51.1</a>&nbsp;&nbsp;一般的なプラグインを書く<br>
<a class="Identifier" href="usr_51.html#51.2">51.2</a>&nbsp;&nbsp;ファイルタイププラグインを書く<br>
<a class="Identifier" href="usr_51.html#51.3">51.3</a>&nbsp;&nbsp;コンパイラプラグインを書く<br>
<a class="Identifier" href="usr_51.html#51.4">51.4</a>&nbsp;&nbsp;プラグインを書く (高速ロード版)<br>
<a class="Identifier" href="usr_51.html#51.5">51.5</a>&nbsp;&nbsp;ライブラリスクリプトを書く<br>
<a class="Identifier" href="usr_51.html#51.6">51.6</a>&nbsp;&nbsp;Vim script を配布する<br>
<br>
次章:&nbsp;<a class="Identifier" href="usr_52.html">usr_52.txt</a>&nbsp;&nbsp;Vim9 script でプラグインを作る<br>
前章:&nbsp;<a class="Identifier" href="usr_50.html">usr_50.txt</a>&nbsp;&nbsp;高度な Vim script の書き方<br>
目次:&nbsp;<a class="Identifier" href="usr_toc.html">usr_toc.txt</a><br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_51.html#51.1" name="51.1">51.1</a>&nbsp;&nbsp;一般的なプラグインを書く&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_51.html#write-plugin" name="write-plugin">write-plugin</a><br>
<br>
Vim script を書いて、それを多くの人に使ってもらうことができます。そのようなス<br>
クリプトはプラグインと呼ばれます。Vim ユーザーはあなたのスクリプトをプラグイン<br>
ディレクトリにコピーするだけで、すぐにその機能を使うことができます。<br>
<a class="Identifier" href="usr_05.html#add-plugin">add-plugin</a>&nbsp;参照。<br>
<br>
プラグインには二種類あります:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;グローバルプラグイン : すべてのファイルで共通<br>
&nbsp;&nbsp;ファイルタイププラグイン : ファイルの種類別<br>
<br>
この節ではグローバルプラグインについて説明します。ほとんどの説明はファイルタイ<br>
ププラグインに対してもあてはまります。ファイルタイププラグイン特有の説明は次節<br>
にあります&nbsp;<a class="Identifier" href="usr_51.html#write-filetype-plugin">write-filetype-plugin</a>。<br>
<br>
<br>
名前<br>
<span class="PreProc">-----</span><br>
<br>
最初にプラグインの名前を決めなければなりません。プラグインが提供する機能が名前<br>
から分かるようにしてください。また、他の人が作ったプラグインと名前がかぶらない<br>
ようにしてください。<br>
<br>
例えばタイプミス (type mistake) を修正 (correct) するためのスクリプトなら<br>
&quot;typecorrect.vim&quot; という名前を付けたりします。ここではこれを例題として使いま<br>
す。<br>
<br>
プラグインが誰でも使えるようにするため、いくつかのガイドラインに従ってくださ<br>
い。ガイドラインは段階的に説明していきます。例題プラグインの完全なソースは最後<br>
に示します。<br>
<br>
<br>
ボディ<br>
<span class="PreProc">------</span><br>
<br>
まずはプラグインの本体部分を見てみましょう。行番号は実際の番号です:<br>
<br>
<div class="helpExample">&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp; iabbrev teh the<br>
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp; iabbrev otehr other<br>
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp; iabbrev wnat want<br>
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp; iabbrev synchronisation<br>
&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ synchronization</div>
<br>
もちろん、実際のスクリプトはもっと巨大です。<br>
<br>
行番号は説明のために追加したものです。プラグインを書くときは行番号を付けないで<br>
ください。<br>
<br>
<br>
最初の行<br>
<br>
<div class="helpExample">&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; vim9script noclear</div>
<br>
<span class="Comment">vimi9script</span>&nbsp;を一番最初のコマンドとして使用する必要があります。一番最初の行に<br>
記述するのがベストです。<br>
<br>
作成しているスクリプトは、2回目にロードされたときに終了するための&nbsp;<a class="Comment" href="repeat.html#:finish">finish</a>&nbsp;コ<br>
マンドがあります。スクリプトで定義された項目が失われるのを防ぐために、<br>
&quot;noclear&quot; 引数を使用します。詳しくは&nbsp;<a class="Identifier" href="vim9.html#vim9-reload">vim9-reload</a>&nbsp;をご覧ください。<br>
<br>
<br>
ヘッダー<br>
<span class="PreProc">------</span><br>
<br>
新しい単語を追加していくと、プラグインには複数のバージョンが存在することになり<br>
ます。ファイルを配布したとき、それを使った人は、誰がこの素晴らしいプラグインを<br>
書いたのかを知りたいと思うでしょうし、感想を伝えたいと思うかもしれません。<br>
というわけで、次のようなヘッダーをプラグインに書いてください:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp; # Vim global plugin for correcting typing mistakes<br>
&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp; # Last Change:&nbsp;&nbsp;2021 Dec 30<br>
&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp; # Maintainer:&nbsp;&nbsp; Bram Moolenaar &lt;Bram@vim.org&gt;</div>
<br>
著作権とライセンスについて: プラグインがとても便利で、そして再配布を制限するほ<br>
どのものでない場合は、パブリックドメインか Vim ライセンス (<a class="Identifier" href="uganda.html#license">license</a>) の適用を<br>
検討してみてください。次の短い宣言をプラグインの先頭付近に書いておくだけで十分<br>
です:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp; # License:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This file is placed in the public domain.</div>
<br>
<br>
行継続と副作用の回避&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_51.html#use-cpo-save" name="use-cpo-save">use-cpo-save</a><br>
<span class="PreProc">--------------------</span><br>
<br>
上の例の 18 行目では行継続 (<a class="Identifier" href="repeat.html#line-continuation">line-continuation</a>) が使われています。ユーザーの<br>
環境で&nbsp;<a class="Type" href="options.html#'compatible'">'compatible'</a>&nbsp;オプションがオンに設定されていると、この行でエラーが発生し<br>
ます。<a class="Type" href="options.html#'compatible'">'compatible'</a>&nbsp;オプションの設定には副作用があるので、勝手に設定をオフにす<br>
ることはできません。代わりに、一時的に&nbsp;<a class="Type" href="options.html#'cpoptions'">'cpoptions'</a>&nbsp;の値を Vim のデフォルト値に<br>
設定し、後で元に戻します。そうすれば、行連結を使うことができ、スクリプトはほと<br>
んどの環境で動作するようになります。設定の変更は次のようにします:<br>
<br>
<div class="helpExample">&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp; var save_cpo = &amp;cpo<br>
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp; set cpo&amp;vim<br>
&nbsp;..<br>
&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp; &amp;cpo = save_cpo</div>
<br>
最初に&nbsp;<a class="Type" href="options.html#'cpoptions'">'cpoptions'</a>&nbsp;の値を &quot;save_cpo&quot; 変数に保存します。プラグインの最後でオプ<br>
ションの値を元に戻します。<br>
<br>
&quot;save_cpo&quot; がスクリプトローカル変数であることに注目してください。グローバル変<br>
数は他の場所で使われている可能性があります。スクリプトの中だけで使う場合はスク<br>
リプトローカル変数を使ってください。<br>
<br>
<br>
ロードしない<br>
<span class="PreProc">------------</span><br>
<br>
ユーザーが常にプラグインをロードしたいと思うとは限りません。また、システム管理<br>
者がシステムのプラグインディレクトリにプラグインを入れたが、ユーザーは自分で入<br>
れたプラグインを使いたいということもあります。したがって、指定したプラグインだ<br>
けを無効にできる必要があります。次の行のようにします:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp; if exists(&quot;g:loaded_typecorrect&quot;)<br>
&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; finish<br>
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp; endif<br>
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp; g:loaded_typecorrect = 1</div>
<br>
これはスクリプトの2重ロードで関数が無意味に再定義されることと自動コマンドが2重<br>
に追加されるのを避ける効果もあります。<br>
<br>
変数の名前は &quot;g:loaded_&quot; で始めてプラグインのファイル名をそのまま付けるように<br>
してください。&quot;g:&quot; を付けることで変数をグローバルにし、他の箇所で機能があるか<br>
チェックできるようにします。&quot;g:&quot; を付けないとスクリプトローカルになります。<br>
<br>
<a class="Comment" href="repeat.html#:finish">finish</a>&nbsp;を使ってファイルの残りの部分の読み込みを停止しています。Vimはコマンド<br>
を解析して&nbsp;<a class="Comment" href="eval.html#:endif">endif</a>&nbsp;を見つける必要があるため、この方法はファイル全体を if-endif<br>
で囲むよりもはるかに高速です。<br>
<br>
<br>
マップ<br>
<span class="PreProc">------</span><br>
<br>
さて、プラグインをもっと魅力あるものに仕上げましょう。マップを追加して、カーソ<br>
ルの下の単語に対する修正を追加できるようにします。単純にキーを選んでマップを設<br>
定することもできますが、そのキーは既にユーザーが使っているかもしれません。マッ<br>
プに使用するキーをユーザーが選択できるようにするには、<span class="Special">&lt;Leader&gt;</span>&nbsp;を使います:<br>
<br>
<div class="helpExample">&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; map &lt;unique&gt; &lt;Leader&gt;a&nbsp;&nbsp;&lt;Plug&gt;TypecorrAdd;</div>
<br>
&quot;<span class="Special">&lt;Plug&gt;</span>TypecorrAdd;&quot; は目的の動作をします。詳しくは後で説明します。<br>
<br>
使用したいキーを &quot;g:mapleader&quot; 変数に設定することで、プラグインのマップの最初<br>
のキーを設定できます。例えば、次のように設定すると:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:mapleader = &quot;_&quot;</div>
<br>
マップは &quot;_a&quot; と定義されます。変数が設定されていない場合は初期設定 (バックス<br>
ラッシュ) が使われます。つまり &quot;\a&quot; というマップが定義されます。<br>
<br>
<span class="Todo">Note</span>: 上記のコマンドでは&nbsp;<span class="Special">&lt;unique&gt;</span>&nbsp;が使われています。これは、同じマップが既に定<br>
義されていた場合にエラーを表示します。<a class="Identifier" href="map.html#:map-<unique>">:map-&lt;unique&gt;</a><br>
<br>
マップするキーをユーザーが自分で定義できるようにするには、次のようにします:<br>
<br>
<div class="helpExample">&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp; if !hasmapto('&lt;Plug&gt;TypecorrAdd;')<br>
&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; map &lt;unique&gt; &lt;Leader&gt;a&nbsp;&nbsp;&lt;Plug&gt;TypecorrAdd;<br>
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp; endif</div>
<br>
&quot;<span class="Special">&lt;Plug&gt;</span>TypecorrAdd;&quot; に対するマップが既にあるかどうかを調べ、無い場合のみ<br>
&quot;<span class="Special">&lt;Leader&gt;</span>a&quot; にマップを定義します。ユーザーは自分の vimrc ファイルの中でマップ<br>
を定義することができます:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map ,c&nbsp;&nbsp;&lt;Plug&gt;TypecorrAdd;</div>
<br>
すると、マップのキーとして &quot;,c&quot; が使われます。&quot;_a&quot; や &quot;\a&quot; は使われません。<br>
<br>
<br>
ピース<br>
<span class="PreProc">------</span><br>
<br>
スクリプトが大きくなると、それを部品ごとに分けたくなります。それには関数やマッ<br>
プを使います。しかし、そうすると関数やマップが他のスクリプトのものと衝突する可<br>
能性があります。例えば、Add() という関数を追加したとき、他のスクリプトでも同じ<br>
名前の関数が定義されているかもしれません。そのような場合は、スクリプトの中だけ<br>
で使える関数を定義します。<br>
幸いにも、<a class="Identifier" href="vim9.html#Vim9">Vim9</a>&nbsp;script では、これがデフォルトです。旧来のスクリプトでは、名前<br>
の前に &quot;s:&quot; を付ける必要があります。<br>
<br>
新しい修正を追加するための関数を定義します:<br>
<br>
<div class="helpExample">&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp; def Add(from: string, correct: bool)<br>
&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var to = input($&quot;type the correction for {from}: &quot;)<br>
&nbsp;32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exe $&quot;:iabbrev {from} {to}&quot;<br>
&nbsp;..<br>
&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp; enddef</div>
<br>
Add() 関数は同じスクリプトの中から呼び出すことができます。他のスクリプトが<br>
Add() を定義していた場合、それはそのスクリプトにローカルであり、スクリプトの中<br>
からのみ呼び出すことができます。さらにグローバルの g:Add() 関数を定義すること<br>
もでき、それはまた別の関数になります。<br>
<br>
マップ定義では&nbsp;<span class="Special">&lt;SID&gt;</span>&nbsp;が使えます。これは、現在のスクリプトを識別するためのスク<br>
リプト ID を生成します。私たちの入力修正プラグインでは&nbsp;<span class="Special">&lt;SID&gt;</span>&nbsp;を次のように使い<br>
ます:<br>
<br>
<div class="helpExample">&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp; noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd;&nbsp;&nbsp;&lt;SID&gt;Add<br>
&nbsp;..<br>
&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp; noremap &lt;SID&gt;Add&nbsp;&nbsp;:call &lt;SID&gt;Add(expand(&quot;&lt;cword&gt;&quot;), true)&lt;CR&gt;</div>
<br>
ユーザーが &quot;\a&quot; と入力すると、次の手順でキー入力が呼び出されます:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\a&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&lt;Plug&gt;TypecorrAdd;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&lt;SID&gt;Add&nbsp;&nbsp;-&gt;&nbsp;&nbsp;:call &lt;SID&gt;Add(...)</div>
<br>
他のスクリプトで&nbsp;<span class="Special">&lt;SID&gt;</span>Add をマップすると、別のスクリプト ID が使われ、別のマッ<br>
プが生成されます。<br>
<br>
<span class="Todo">Note</span>: Add() ではなく&nbsp;<span class="Special">&lt;SID&gt;</span>Add() と書いていることに注意してください。マップはス<br>
クリプトコンテキストの外側でユーザーが入力するものだからです。<span class="Special">&lt;SID&gt;</span>&nbsp;はスクリプ<br>
ト ID に変換され、どのスクリプトの Add() 関数を呼べばいいのかわかるようになっ<br>
ています。<br>
<br>
これは少し複雑ですが、複数のプラグインを同時に使用するためには必要なことです。<br>
基本的なルールとしては、マップの中では&nbsp;<span class="Special">&lt;SID&gt;</span>Add() を使い、他の場所 (スクリプト<br>
の中、自動コマンド、ユーザー定義コマンド) では Add() を使います。<br>
<br>
マップと同じ方法で、メニューを追加することもできます:<br>
<br>
<div class="helpExample">&nbsp;26&nbsp;&nbsp;&nbsp;&nbsp; noremenu &lt;script&gt; Plugin.Add\ Correction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SID&gt;Add</div>
<br>
プラグインのメニューを追加する場合は &quot;Plugin&quot; メニューの下に登録することが推奨<br>
されています。この例ではメニューが一つだけですが、複数のメニューを追加する場合<br>
は、サブメニューの使用が推奨されています。例えば、&quot;Plugin.CVS&quot; 以下に<br>
&quot;Plugin.CVS.checkin&quot; や &quot;Plugin.CVS.checkout&quot; などの CVS の操作を登録します。<br>
<br>
<span class="Todo">Note</span>: 28 行目では &quot;:noremap&quot; を使って、他のマップでトラブルが起きないようにし<br>
ています。例えば、誰かが &quot;:call&quot; をマップしているかもしれないからです。24 行目<br>
でも &quot;:noremap&quot; を使っていますが、ここでは &quot;<span class="Special">&lt;SID&gt;</span>Add&quot; を再マップして欲しいの<br>
で、&quot;<span class="Special">&lt;script&gt;</span>&quot; を使っています。これを使うとスクリプトローカルなマップだけが再<br>
マップされます&nbsp;<a class="Identifier" href="map.html#:map-<script>">:map-&lt;script&gt;</a>。26 行目でも &quot;:noremenu&quot; で同様のことをしていま<br>
す&nbsp;<a class="Identifier" href="gui.html#:menu-<script>">:menu-&lt;script&gt;</a>。<br>
<br>
<br>
<span class="Special">&lt;SID&gt;</span>&nbsp;と&nbsp;<span class="Special">&lt;Plug&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_51.html#using-<Plug>" name="using-&lt;Plug&gt;">using-&lt;Plug&gt;</a><br>
<span class="PreProc">---------------</span><br>
<br>
<span class="Special">&lt;SID&gt;</span>&nbsp;と&nbsp;<span class="Special">&lt;Plug&gt;</span>&nbsp;は、入力したキーに対するマップと、他のマップの中だけで使われる<br>
マップが干渉しないようにするために使われます。<span class="Special">&lt;SID&gt;</span>&nbsp;と&nbsp;<span class="Special">&lt;Plug&gt;</span>&nbsp;の違いに注意して<br>
ください:<br>
<br>
<span class="Special">&lt;Plug&gt;</span>&nbsp;&nbsp;これはスクリプトの外側からも見えます。ユーザーが自分でプラグインの機能<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;をマップできるようにするような場合に使います。<span class="Special">&lt;Plug&gt;</span>&nbsp;は特殊なコード<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;で、キーボードから入力されることはありません。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;キー列が他のプラグインとかぶらないように、<span class="Special">&lt;Plug&gt;</span>&nbsp;スクリプト名 マップ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;名、という形式で使ってください。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;セミコロンを終端として追加しています。我々の例では、スクリプト名が<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Typecorr&quot;、マップ名が &quot;Add&quot; なので、&quot;<span class="Special">&lt;Plug&gt;</span>TypecorrAdd;&quot; というキー列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;になります。スクリプト名とマップ名の最初の文字だけを大文字にして、どこ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;がマップ名なのかわかるようにします。<br>
<br>
<span class="Special">&lt;SID&gt;</span>&nbsp;&nbsp; これはスクリプト ID (スクリプト固有の識別子) です。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vim は内部で&nbsp;<span class="Special">&lt;SID&gt;</span>&nbsp;を &quot;<span class="Special">&lt;SNR&gt;</span>123_&quot; に変換します (&quot;123&quot; の部分はいろいろ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;な数字が入ります)。つまり、関数 &quot;<span class="Special">&lt;SID&gt;</span>Add()&quot; は、あるスクリプトでは<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span class="Special">&lt;SNR&gt;</span>11_Add()&quot; という名前になり、別のスクリプトでは &quot;<span class="Special">&lt;SNR&gt;</span>22_Add()&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;になります。これは &quot;:function&quot; コマンドで関数一覧を表示すると確認する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ことができます。<span class="Special">&lt;SID&gt;</span>&nbsp;の変換はマップの中でも同様におこなわれるので、<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マップの中からスクリプトローカル関数を呼び出すことができます。<br>
<br>
<br>
ユーザー定義コマンド<br>
<span class="PreProc">------------------</span><br>
<br>
修正を追加するためのユーザー定義コマンドを追加します:<br>
<br>
<div class="helpExample">&nbsp;38&nbsp;&nbsp;&nbsp;&nbsp; if !exists(&quot;:Correct&quot;)<br>
&nbsp;39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command -nargs=1&nbsp;&nbsp;Correct&nbsp;&nbsp;:call Add(&lt;q-args&gt;, false)<br>
&nbsp;40&nbsp;&nbsp;&nbsp;&nbsp; endif</div>
<br>
ユーザー定義コマンドは、同じ名前のコマンドがまだない場合のみ定義できます。既に<br>
定義されている場合はエラーになります。&quot;:command!&quot; を使ってユーザー定義関数を上<br>
書きするのは良いアイデアとは言えません。ユーザーは、自分が定義したコマンドがな<br>
ぜ動かないのか不思議に思うでしょう。<a class="Identifier" href="map.html#:command">:command</a><br>
だれの責任でそうなってしまったのか見付けるには:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verbose command Correct</div>
<br>
<br>
スクリプト変数<br>
<span class="PreProc">--------------</span><br>
<br>
先頭に &quot;s:&quot; が付いた変数はスクリプト変数です。これはスクリプトの中だけで使えま<br>
す。スクリプトの外からは見えません。同じ名前の変数を複数のスクリプトで使ってし<br>
まうようなトラブルを避けることができます。Vim が実行されている間、変数は保持さ<br>
れます。そして、同じスクリプトが再読み込みされると、再び同じ変数が使われます。<br>
<a class="Identifier" href="eval.html#s:var">s:var</a><br>
<br>
スクリプト変数は、同じスクリプトの中で定義された関数、自動コマンド、ユーザー定<br>
義コマンドでも使えます。我々の例に、修正の数を数えるための数行のコードを追加し<br>
ます<br>
<br>
<a class="Identifier" href="vim9.html#Vim9">Vim9</a>&nbsp;script の良いところは、変数がデフォルトでスクリプトローカルであるという<br>
ことです。必要に応じて &quot;s:&quot; を前に付けることができますが、そうする必要はありま<br>
せん。また、スクリプト内の関数も、プリフィックスなしでスクリプト変数を使用する<br>
ことができます。<br>
<br>
スクリプトローカル変数は、スクリプト内で定義した関数、自動コマンド、ユーザーコ<br>
マンド内でも使用できます。したがって、プラグイン内の部品間で情報を漏らさずに共<br>
有するための最適な方法です。この例では、修正回数を数えるための行をいくつか追加<br>
することができます:<br>
<br>
<div class="helpExample">&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp; var count = 4<br>
&nbsp;..<br>
&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp; def Add(from: string, correct: bool)<br>
&nbsp;..<br>
&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += 1<br>
&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo &quot;you now have &quot; .. count .. &quot; corrections&quot;<br>
&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp; enddef</div>
<br>
&quot;count&quot; はスクリプト内の 4 で宣言と初期化がされます。その後、Add() 関数が呼び<br>
出されると、&quot;count&quot; がインクリメントされます。関数がどこから呼ばれたかにかかわ<br>
らず、関数が定義されたスクリプトのローカル変数を使用します。<br>
<br>
<br>
まとめ<br>
<span class="PreProc">------</span><br>
<br>
例題の完成形は以下のようになります:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; vim9script noclear<br>
&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp; # Vim global plugin for correcting typing mistakes<br>
&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp; # Last Change:&nbsp;&nbsp;2021 Dec 30<br>
&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp; # Maintainer:&nbsp;&nbsp; Bram Moolenaar &lt;Bram@vim.org&gt;<br>
&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp; # License:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This file is placed in the public domain.<br>
&nbsp;&nbsp;6<br>
&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp; if exists(&quot;g:loaded_typecorrect&quot;)<br>
&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; finish<br>
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp; endif<br>
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp; g:loaded_typecorrect = 1<br>
&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp; var save_cpo = &amp;cpo<br>
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp; set cpo&amp;vim<br>
&nbsp;13<br>
&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp; iabbrev teh the<br>
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp; iabbrev otehr other<br>
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp; iabbrev wnat want<br>
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp; iabbrev synchronisation<br>
&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ synchronization<br>
&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp; var count = 4<br>
&nbsp;20<br>
&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp; if !hasmapto('&lt;Plug&gt;TypecorrAdd;')<br>
&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; map &lt;unique&gt; &lt;Leader&gt;a&nbsp;&nbsp;&lt;Plug&gt;TypecorrAdd;<br>
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp; endif<br>
&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp; noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd;&nbsp;&nbsp;&lt;SID&gt;Add<br>
&nbsp;25<br>
&nbsp;26&nbsp;&nbsp;&nbsp;&nbsp; noremenu &lt;script&gt; Plugin.Add\ Correction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SID&gt;Add<br>
&nbsp;27<br>
&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp; noremap &lt;SID&gt;Add&nbsp;&nbsp;:call &lt;SID&gt;Add(expand(&quot;&lt;cword&gt;&quot;), true)&lt;CR&gt;<br>
&nbsp;29<br>
&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp; def Add(from: string, correct: bool)<br>
&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var to = input(&quot;type the correction for &quot; .. from .. &quot;: &quot;)<br>
&nbsp;32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exe &quot;:iabbrev &quot; .. from .. &quot; &quot; .. to<br>
&nbsp;33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if correct | exe &quot;normal viws\&lt;C-R&gt;\&quot; \b\e&quot; | endif<br>
&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += 1<br>
&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo &quot;you now have &quot; .. count .. &quot; corrections&quot;<br>
&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp; enddef<br>
&nbsp;37<br>
&nbsp;38&nbsp;&nbsp;&nbsp;&nbsp; if !exists(&quot;:Correct&quot;)<br>
&nbsp;39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command -nargs=1&nbsp;&nbsp;Correct&nbsp;&nbsp;call Add(&lt;q-args&gt;, false)<br>
&nbsp;40&nbsp;&nbsp;&nbsp;&nbsp; endif<br>
&nbsp;41<br>
&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp; &amp;cpo = save_cpo</div>
<br>
33 行目は説明がまだでした。これは、新しい修正をカーソルの下の単語に適用しま<br>
す。<a class="Identifier" href="various.html#:normal">:normal</a>&nbsp;コマンドを使って新しい略語を適用しています。<span class="Todo">Note</span>: マップと略語は<br>
その場で展開されます。&quot;:noremap&quot; で定義されたマップから関数が呼び出されたとし<br>
ても動作は同じです。<br>
<br>
<br>
ドキュメント&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_51.html#write-local-help" name="write-local-help">write-local-help</a><br>
<span class="PreProc">------------</span><br>
<br>
プラグインのドキュメントを書くのは良いアイデアです。ユーザーが動作を変更できる<br>
ような場合には特に重要です。<a class="Identifier" href="usr_05.html#add-local-help">add-local-help</a>&nbsp;ではどのようにしてドキュメントが<br>
インストールされるか説明されています。<br>
<br>
プラグインヘルプファイルの例を示します (&quot;typecorrect.txt&quot;):<br>
<br>
<div class="helpExample">&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; *typecorrect.txt*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Plugin for correcting typing mistakes<br>
&nbsp;&nbsp;2<br>
&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp; If you make typing mistakes, this plugin will have them corrected<br>
&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp; automatically.<br>
&nbsp;&nbsp;5<br>
&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp; There are currently only a few corrections.&nbsp;&nbsp;Add your own if you like.<br>
&nbsp;&nbsp;7<br>
&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp; Mappings:<br>
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp; &lt;Leader&gt;a&nbsp;&nbsp; or&nbsp;&nbsp; &lt;Plug&gt;TypecorrAdd;<br>
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add a correction for the word under the cursor.<br>
&nbsp;11<br>
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp; Commands:<br>
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp; :Correct {word}<br>
&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add a correction for {word}.<br>
&nbsp;15<br>
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *typecorrect-settings*<br>
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp; This plugin doesn't have any settings.</div>
<br>
書式に気をつけなければならないのは一行目だけです。一行目はコピーされ、help.txt<br>
の &quot;LOCAL ADDITIONS:&quot; の項に埋め込まれます&nbsp;<a class="Identifier" href="index.html#local-additions">local-additions</a>。最初の &quot;*&quot; は一<br>
行目の一桁目に書いてください。ヘルプを追加したら &quot;:help&quot; を実行して項目が追加<br>
されたことを確認してください。<br>
<br>
ヘルプの中で ** で文字を囲むとタグを追加することができます。ただし、既存のヘル<br>
プタグと同じものを使わないでください。&quot;typecorrect-settings&quot; のように、プラグ<br>
インの名前を使ってタグを作るといいかもしれません。<br>
<br>
ヘルプの他の部分を参照するときは || で囲みます。そうすれば、ユーザーは簡単にヘ<br>
ルプの関連した部分を参照することができます。<br>
<br>
<br>
ファイルタイプの認識&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_51.html#plugin-filetype" name="plugin-filetype">plugin-filetype</a><br>
<span class="PreProc">--------------------</span><br>
<br>
ファイルタイプが Vim によって認識されない場合は、別ファイルにファイルタイプを<br>
認識するためにコードを作成する必要があります。通常は、自動コマンドを使って、<br>
ファイル名がパターンにマッチしたときにファイルタイプを設定します。例:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;au BufNewFile,BufRead *.foo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setlocal filetype=foofoo</div>
<br>
この一行を&nbsp;<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>&nbsp;の最初のディレクトリの &quot;ftdetect/foofoo.vim&quot; に書き<br>
込みます。例えば、Unix なら &quot;~/.vim/ftdetect/foofoo.vim&quot; などです。ファイルタ<br>
イプとスクリプトファイルの名前を同じにする決まりになっています。<br>
<br>
必要ならより複雑な処理をすることもできます。例えば、ファイルの中身を見て言語を<br>
判定したりできます。<a class="Identifier" href="filetype.html#new-filetype">new-filetype</a>&nbsp;も参照。<br>
<br>
<br>
要約&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_51.html#plugin-special" name="plugin-special">plugin-special</a><br>
<span class="PreProc">-----</span><br>
<br>
プラグインで使用する特有事項の要約を示します:<br>
<br>
var name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;スクリプトローカル変数。<br>
<br>
<span class="Special">&lt;SID&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; スクリプトID。マップや関数をスクリプトローカルにする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;のに使う。<br>
<br>
hasmapto()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;スクリプトが提供している機能に対して、ユーザーが既に<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マップを定義したかどうかをチェックする関数。<br>
<br>
<span class="Special">&lt;Leader&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;mapleader&quot; の値。ユーザーがその変数にキーを設定するこ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;とで、プラグインのマップの開始キーを指定できる。<br>
<br>
map&nbsp;<span class="Special">&lt;unique&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マップが既に定義されているなら警告を発する。<br>
<br>
noremap&nbsp;<span class="Special">&lt;script&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;スクリプトローカルマップだけを使う。グローバルマップは<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使わない。<br>
<br>
exists(&quot;:Cmd&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ユーザー定義コマンドが既にあるかどうかをチェックする。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_51.html#51.2" name="51.2">51.2</a>&nbsp;&nbsp;ファイルタイププラグインを書く&nbsp;&nbsp;<a class="Constant" href="usr_51.html#write-filetype-plugin" name="write-filetype-plugin">write-filetype-plugin</a>&nbsp;<a class="Constant" href="usr_51.html#ftplugin" name="ftplugin">ftplugin</a><br>
<br>
ファイルタイププラグインはグローバルプラグインと似ていますが、カレントバッファ<br>
のマップやオプションだけを設定します。ファイルタイププラグインの使用方法につい<br>
ては&nbsp;<a class="Identifier" href="usr_05.html#add-filetype-plugin">add-filetype-plugin</a>&nbsp;を参照してください。<br>
<br>
先に&nbsp;<a class="Identifier" href="usr_51.html#51.1">51.1</a>&nbsp;節のグローバルプラグインの項を読んでください。そこで説明されている<br>
ことはすべてファイルタイププラグインにもあてはまります。この節ではファイルタイ<br>
ププラグイン特有の事項だけを説明します。ファイルタイププラグインはカレントバッ<br>
ファに対してのみ機能するということが最も大切です。<br>
<br>
<br>
無効化<br>
<span class="PreProc">------</span><br>
<br>
ファイルタイププラグインを書いて多くの人に使ってもらおうとするなら、プラグイン<br>
を無効化できるようにしておく必要があります。プラグインの先頭に次のような記述を<br>
追加してください:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# このバッファに対してまだ実行されていない場合のみ処理を実行する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if exists(&quot;b:did_ftplugin&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b:did_ftplugin = 1</div>
<br>
これは同じプラグインが同じバッファで二重にロードされるのを防ぐためにも必要です<br>
(&quot;:edit&quot; コマンドを引数なしで実行したときに発生します)。<br>
<br>
ユーザーは、次の行を書いたファイルタイププラグインを作成することで、標準プラグ<br>
インのロードを無効化できます:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vim9script<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b:did_ftplugin = 1</div>
<br>
ただし、そのファイルを保存したファイルタイププラグインディレクトリが、<br>
<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>&nbsp;の中で $VIMRUNTIME よりも前にある必要があります。<br>
<br>
標準プラグインを使いつつ、その設定を一つだけ変更したいという場合は、スクリプト<br>
の中で設定を変更することができます:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setlocal textwidth=70</div>
<br>
このファイルを &quot;after&quot; ディレクトリに保存すると、(例えば filetype=vim なら) 標<br>
準配布の &quot;vim.vim&quot; が読み込まれた後に、保存したファイルが読み込まれるようにな<br>
ります&nbsp;<a class="Identifier" href="options.html#after-directory">after-directory</a>。Unix ならファイルのパスは<br>
&quot;~/.vim/after/ftplugin/vim.vim&quot; です。<span class="Todo">Note</span>: 標準プラグインは &quot;b:did_ftplugin&quot;<br>
を設定しますが、ここではそれを無視しています。<br>
<br>
<br>
オプション<br>
<span class="PreProc">----------</span><br>
<br>
ファイルタイププラグインでは、カレントバッファの設定だけを変更するため、次のコ<br>
マンドを使ってオプションを設定してください:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setlocal</div>
<br>
そして、バッファローカルなオプションだけを設定してください (どのオプションがそ<br>
うなのかはヘルプで確認してください)。<a class="Comment" href="options.html#:setlocal">:setlocal</a>&nbsp;コマンドでグローバルオプショ<br>
ンやウィンドウローカルオプションを設定すると、たくさんのバッファの設定が変更さ<br>
れます。ファイルタイププラグインはそのような動作をすべきではありません。<br>
<br>
オプションの値がフラグや設定項目のリストなら、&quot;+=&quot; や &quot;-=&quot; を使うことで既存の<br>
設定を維持することができます。ユーザーがそのオプションの設定を変更している可能<br>
性もあるので注意してください。最初に初期設定に戻してから設定を変更するといいか<br>
もしれません。例:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setlocal formatoptions&amp; formatoptions+=ro</div>
<br>
<br>
マップ<br>
<span class="PreProc">------</span><br>
<br>
カレントバッファの中だけで機能するマップを作るには次のコマンドを使います:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map &lt;buffer&gt;</div>
<br>
上述したように、マップは二段階に分けて作る必要があります。ファイルタイププラグ<br>
インで機能を定義する例を示します:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !hasmapto('&lt;Plug&gt;JavaImport;')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map &lt;buffer&gt; &lt;unique&gt; &lt;LocalLeader&gt;i &lt;Plug&gt;JavaImport;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;noremap &lt;buffer&gt; &lt;unique&gt; &lt;Plug&gt;JavaImport; oimport &quot;&quot;&lt;Left&gt;&lt;Esc&gt;</div>
<br>
<a class="Identifier" href="builtin.html#hasmapto()">hasmapto()</a>&nbsp;を使って、ユーザーが既に&nbsp;<span class="Special">&lt;Plug&gt;</span>JavaImport; に対してマップを定義し<br>
ているかどうかを調べます。未定義ならファイルタイププラグインの標準のマップを定<br>
義します。マップは&nbsp;<span class="Special">&lt;LocalLeader&gt;</span>&nbsp;で開始します。そうすることで、ファイルタイプ<br>
プラグインのマップを開始するキーをユーザーが選択できます。初期設定はバックス<br>
ラッシュです。<br>
&quot;<span class="Special">&lt;unique&gt;</span>&quot; を使って、マップが既に存在したとき、あるいは既存のマップと重複した<br>
ときにエラーメッセージが表示されるようにします。<br>
<a class="Identifier" href="map.html#:noremap">:noremap</a>&nbsp;を使って、ユーザーが定義した他のマップの影響を受けないようにしま<br>
す。&quot;:noremap&nbsp;<span class="Special">&lt;script&gt;</span>&quot; を使うと、スクリプトの中で定義した&nbsp;<span class="Special">&lt;SID&gt;</span>&nbsp;で始まるマッ<br>
プだけが再マップされます。<br>
<br>
ユーザーがファイルタイププラグインのマップを無効化できる仕組みを提供しなければ<br>
なりません。例えば、&quot;mail&quot; ファイルタイプのプラグインなら次のようにします:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# マップを追加する。ユーザーが望まない場合は追加しない。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !exists(&quot;g:no_plugin_maps&quot;) &amp;&amp; !exists(&quot;g:no_mail_maps&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# &quot;&gt; &quot; を挿入して引用する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !hasmapto('&lt;Plug&gt;MailQuote;')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote; :s/^/&gt; /&lt;CR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote; :.,$s/^/&gt; /&lt;CR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</div>
<br>
ここでは二つのグローバル変数が使われています:<br>
<a class="Identifier" href="filetype.html#g:no_plugin_maps">g:no_plugin_maps</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;すべてのファイルタイププラグインのマップを無効化<br>
<a class="Identifier" href="filetype.html#g:no_mail_maps">g:no_mail_maps</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;mail&quot; ファイルタイプのマップを無効化<br>
<br>
<br>
ユーザー定義コマンド<br>
<span class="PreProc">--------------------</span><br>
<br>
ファイルタイプ用のユーザー定義コマンドを追加して、それを一つのバッファの中だけ<br>
で使えるようにするには、<a class="Identifier" href="map.html#:command">:command</a>&nbsp;の引数に &quot;-buffer&quot; を指定します。例:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command -buffer&nbsp;&nbsp;Make&nbsp;&nbsp;make %:r.s</div>
<br>
<br>
変数<br>
<span class="PreProc">-----</span><br>
<br>
ファイルタイププラグインは対応するすべてのバッファに対して実行されます。スクリ<br>
プトローカル変数はすべての実行で共有されます。バッファごとの変数を使いたい場合<br>
はバッファローカル変数&nbsp;<a class="Identifier" href="eval.html#b:var">b:var</a>&nbsp;を使ってください。<br>
<br>
<br>
関数<br>
<span class="PreProc">-----</span><br>
<br>
関数は一度だけ定義すれば十分です。しかし、ファイルタイププラグインは対応する<br>
ファイルが開かれるたびに読み込まれます。次のようにすると関数が一度だけ定義され<br>
るようになります:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !exists(&quot;*Func&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def Func(arg)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</div>
<br>
<br>
アンドゥ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_51.html#undo_indent" name="undo_indent">undo_indent</a>&nbsp;<a class="Constant" href="usr_51.html#undo_ftplugin" name="undo_ftplugin">undo_ftplugin</a><br>
<span class="PreProc">--------</span><br>
<br>
ユーザーが &quot;:setfiletype xyz&quot; としたとき、それ以前のファイルタイプの効果は無効<br>
になるべきです。b:undo_ftplugin 変数にコマンドを設定し、ファイルタイププラグイ<br>
ンの設定をアンドゥするようにしてください。例:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let b:undo_ftplugin = &quot;setlocal fo&lt; com&lt; tw&lt; commentstring&lt;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ .. &quot;| unlet b:match_ignorecase b:match_words b:match_skip&quot;</div>
<br>
&quot;:setlocal&quot; でオプション名の後に &quot;&lt;&quot; を付けると、そのオプションをグローバルな<br>
値でリセットします。オプションをリセットするにはこの方法が一番です。<br>
<br>
このように行継続を使うには&nbsp;<a class="Type" href="options.html#'cpoptions'">'cpoptions'</a>&nbsp;から &quot;C&quot; フラグを取り除く必要がありま<br>
す。上述の&nbsp;<a class="Identifier" href="usr_51.html#use-cpo-save">use-cpo-save</a>&nbsp;を参照してください。<br>
<br>
インデントスクリプトの効果をアンドゥする為には、それに応じた b:undo_indent 変<br>
数を設定すべきです。<br>
<br>
これら両方の変数は旧来のスクリプトの文法で使われ、<a class="Identifier" href="vim9.html#Vim9">Vim9</a>&nbsp;の文法では使いません。<br>
<br>
<br>
ファイル名<br>
<span class="PreProc">----------</span><br>
<br>
ファイルタイププラグインのファイル名にはファイルタイプ名が含まれていなければな<br>
りません&nbsp;<a class="Identifier" href="usr_05.html#ftplugin-name">ftplugin-name</a>。次の三つのうちのどれかにしてください:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.../ftplugin/stuff.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.../ftplugin/stuff_foo.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.../ftplugin/stuff/bar.vim<br>
<br>
&quot;stuff&quot; はファイルタイプ名、&quot;foo&quot; と &quot;bar&quot; は任意の名前です。<br>
<br>
<br>
要約&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_51.html#ftplugin-special" name="ftplugin-special">ftplugin-special</a><br>
<span class="PreProc">-----</span><br>
<br>
ファイルタイププラグインの特有事項を要約します:<br>
<br>
<span class="Special">&lt;LocalLeader&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;maplocalleader&quot; の値。ユーザーがその変数にキーを設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;することで、ファイルタイププラグインのマップの開始キー<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;を指定できる。<br>
<br>
map&nbsp;<span class="Special">&lt;buffer&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;バッファローカルなマップを定義する。<br>
<br>
noremap&nbsp;<span class="Special">&lt;script&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同スクリプトで定義している&nbsp;<span class="Special">&lt;SID&gt;</span>&nbsp;で始まるマップだけを<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再マップする。<br>
<br>
setlocal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;カレントバッファのオプションのみ設定する。<br>
<br>
command -buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; バッファローカルなユーザー定義コマンドを定義する。<br>
<br>
exists(&quot;*s:Func&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 関数が定義済かどうかをチェックする。<br>
<br>
プラグイン全般に関する事項は&nbsp;<a class="Identifier" href="usr_51.html#plugin-special">plugin-special</a>&nbsp;を参照してください。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_51.html#51.3" name="51.3">51.3</a>&nbsp;&nbsp;コンパイラプラグインを書く&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_51.html#write-compiler-plugin" name="write-compiler-plugin">write-compiler-plugin</a><br>
<br>
コンパイラプラグインは特定のコンパイラを使うためのオプションを設定します。ユー<br>
ザーは&nbsp;<a class="Identifier" href="quickfix.html#:compiler">:compiler</a>&nbsp;コマンドでその設定を読み込むことができます。設定されるオプ<br>
ションは主に&nbsp;<a class="Type" href="options.html#'errorformat'">'errorformat'</a>&nbsp;と&nbsp;<a class="Type" href="options.html#'makeprg'">'makeprg'</a>&nbsp;です。<br>
<br>
百聞は一見に如かず。次のコマンドですべての標準コンパイラプラグインを開くことが<br>
できます:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next $VIMRUNTIME/compiler/*.vim</div>
<br>
<a class="Comment" href="editing.html#:next">:next</a>&nbsp;と打って次のプラグインファイルに移動してください。<br>
<br>
これらのファイルには二つの特有事項があります。一つは、標準ファイルに対して設定<br>
を追加したり上書きしたりできる仕組みです。標準ファイルの先頭は次のようになって<br>
います:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vim9script<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if exists(&quot;g:current_compiler&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:current_compiler = &quot;mine&quot;</div>
<br>
コンパイラファイルを書いて、それを個人用のランタイムディレクトリ (例えば Unix<br>
なら ~/.vim/compiler) に置いたとき、&quot;current_compiler&quot; 変数を設定することで標<br>
準ファイルの設定をスキップすることができます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_51.html#:CompilerSet" name=":CompilerSet">:CompilerSet</a><br>
二つ目は、&quot;:compiler!&quot; が使われたときは &quot;:set&quot; を使い、&quot;:compiler&quot; が使われた<br>
ときは &quot;:setlocal&quot; を使う仕組みです。Vim はそのために &quot;:CompilerSet&quot; という<br>
ユーザーコマンドを定義します。古い Vim はそれを定義しないので、プラグインの中<br>
で定義してください。例:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;if exists(&quot;:CompilerSet&quot;) != 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;command -nargs=* CompilerSet setlocal &lt;args&gt;<br>
&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;CompilerSet errorformat&amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; use the dfault 'errorformat'<br>
&nbsp;&nbsp;CompilerSet makeprg=nmake</div>
<br>
コンパイラプラグインを書いて、それを Vim の配布物に含めたり、システムのランタ<br>
イムディレクトリに入れたりする場合は、上記の方法を使ってください。<br>
&quot;current_compiler&quot; がユーザープラグインで設定された場合は何も実行しないように<br>
します。<br>
<br>
コンパイラプラグインを書いて標準プラグインの設定を上書きする場合は<br>
&quot;current_compiler&quot; をチェックしないようにします。そのプラグインは最後に読み込<br>
まれないといけないので、<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>&nbsp;の最後にあるディレクトリに置きます。例え<br>
ば、Unix なら ~/.vim/after/compiler などです。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_51.html#51.4" name="51.4">51.4</a>&nbsp;&nbsp;プラグインを書く (高速ロード版)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_51.html#write-plugin-quickload" name="write-plugin-quickload">write-plugin-quickload</a><br>
<br>
プラグインが成長し、とても大きくなることがあります。すると、起動速度は遅くなっ<br>
てきます。例えそのプラグインをたまにしか使わないとしても遅くなります。そういう<br>
ときはクイックロードプラグインの出番です。<br>
<br>
基本的なアイデアはプラグインを二回に分けて読み込むということです。一回目はユー<br>
ザー定義コマンドやマップを定義して機能を提供します。二回目は機能を実装する関数<br>
を定義します。<br>
<br>
スクリプトを二回読み込むことがクイックロードだというと驚かれるかもしれません。<br>
この手法の意味は、一回目は高速に読み込み、スクリプトの重い部分は二回目に後回し<br>
にするということです。二回目の読み込みは、ユーザーが実際にその機能を使用したと<br>
きに発生します。あなたがその機能を常に使うなら、これは逆に遅くなってしまいま<br>
す。<br>
<br>
ここでは FuncUndefined 自動コマンドを使います。Vim 7 以降では代わりの方法があ<br>
ります。<a class="Identifier" href="usr_51.html#51.5">51.5</a>&nbsp;で説明されている&nbsp;<a class="Identifier" href="eval.html#autoload">autoload</a>&nbsp;機能を使う方法です。ここで使用した<br>
旧来のスクリプトの代わりに&nbsp;<a class="Identifier" href="vim9.html#Vim9">Vim9</a>&nbsp;script も使えます。<br>
<br>
次に例を示します:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; クイックロードのデモ用のグローバルプラグイン<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; Last Change:&nbsp;&nbsp;2005 Feb 25<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; Maintainer:&nbsp;&nbsp; Bram Moolenaar &lt;Bram@vim.org&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; License:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This file is placed in the public domain.</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !exists(&quot;s:did_load&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command -nargs=* BNRead&nbsp;&nbsp;call BufNetRead(&lt;f-args&gt;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map &lt;F19&gt; :call BufNetWrite('something')&lt;CR&gt;</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let s:did_load = 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exe 'au FuncUndefined BufNet* source ' .. expand('&lt;sfile&gt;')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function BufNetRead(...)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 'BufNetRead(' .. string(a:000) .. ')'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; read 機能をここに書く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunction</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function BufNetWrite(...)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 'BufNetWrite(' .. string(a:000) .. ')'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; write 機能をここに書く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunction</div>
<br>
このスクリプトが最初に読み込まれたとき、&quot;s:did_load&quot; は設定されていません。<br>
&quot;if&quot; と &quot;endif&quot; の間のコマンドが実行されます。<a class="Identifier" href="repeat.html#:finish">:finish</a>&nbsp;コマンドによって終了<br>
し、スクリプトの残りの部分は実行されません。<br>
<br>
二回目に読み込まれたときは &quot;s:did_load&quot; が存在するので、&quot;endif&quot; 以降のコマンド<br>
が実行されます。この部分では (長くなる可能性のある) BufNetRead() 関数と<br>
BufNetWrite() 関数を定義します。<br>
<br>
このスクリプトをプラグインディレクトリに置くと、Vim の起動時に実行されます。処<br>
理の流れは次のようになります:<br>
<br>
1. 起動時にスクリプトが読み込まれる。&quot;BNRead&quot; コマンドが定義され、<span class="Special">&lt;F19&gt;</span>&nbsp;キーに<br>
&nbsp;&nbsp; マップが設定される。自動コマンドの&nbsp;<a class="Identifier" href="autocmd.html#FuncUndefined">FuncUndefined</a>&nbsp;が定義される。&quot;:finish&quot;<br>
&nbsp;&nbsp; コマンドによってスクリプトが終了する。<br>
<br>
2. ユーザーが BNRead コマンド実行する、または&nbsp;<span class="Special">&lt;F19&gt;</span>&nbsp;キーを押す。BufNetRead()<br>
&nbsp;&nbsp; 関数か BufNetWrite() 関数が呼び出される。<br>
<br>
3. Vim はその関数を見つけることができず、自動コマンドの&nbsp;<a class="Identifier" href="autocmd.html#FuncUndefined">FuncUndefined</a>&nbsp;イベン<br>
&nbsp;&nbsp; トを発行する。関数名が &quot;BufNet*&quot; というパターンにマッチするので、&quot;source<br>
&nbsp;&nbsp; fname&quot; コマンドが実行される。&quot;fname&quot; はスクリプトの名前になります。スクリプ<br>
&nbsp;&nbsp; トがどこに保存されていても、&quot;<span class="Special">&lt;sfile&gt;</span>&quot; が展開されてファイル名になります<br>
&nbsp;&nbsp; (<a class="Identifier" href="builtin.html#expand()">expand()</a>参照)。<br>
<br>
4. スクリプトが再び読み込まれる。&quot;s:did_load&quot; 変数が存在するので関数が定義され<br>
&nbsp;&nbsp; る。<br>
<br>
遅延ロードされる関数の名前が&nbsp;<a class="Identifier" href="autocmd.html#FuncUndefined">FuncUndefined</a>&nbsp;自動コマンドのパターンにマッチし<br>
ていることに注意してください。他のプラグインがこのパターンにマッチする関数を定<br>
義しているとうまく動きません。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_51.html#51.5" name="51.5">51.5</a>&nbsp;&nbsp;ライブラリスクリプトを書く&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_51.html#write-library-script" name="write-library-script">write-library-script</a><br>
<br>
いろいろな場所で同じ機能が必要になることがあります。コードが二、三行以上になる<br>
場合は、それを一つのスクリプトに入れて、他のスクリプトから使えるようにしたくな<br>
ると思います。そのようなスクリプトをライブラリスクリプトと呼びます。<br>
<br>
自分でライブラリスクリプトを読み込むことは可能ですが、同じスクリプトを二重に読<br>
み込まないようにする必要があります。それには&nbsp;<a class="Identifier" href="builtin.html#exists()">exists()</a>&nbsp;関数を使います。例:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !exists('*MyLibFunction')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; runtime library/mylibscript.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyLibFunction(arg)</div>
<br>
<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>&nbsp;に設定されたディレクトリの中の &quot;library/mylibscript.vim&quot; の中で<br>
MyLibFunction() が定義されている必要があります。<br>
<br>
これをより簡単にするために、Vim には autoload という仕組みがあります。同じこと<br>
を次のように書くことができます:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mylib#myfunction(arg)</div>
<br>
この方がずっと簡単でしょう？ Vim は # が含まれる関数の名前を見て、それが未定義<br>
なら、<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>&nbsp;の中から &quot;autoload/mylib.vim&quot; を探します。そのスクリプトは<br>
関数 &quot;mylib#myfunction()&quot; を定義していなければなりません。<br>
<br>
mylib.vim には他の関数も入れられます。ライブラリスクリプトの中では自由に関数を<br>
作ることができます。ただし、関数名の '#' より前の部分はスクリプトの名前と同じ<br>
にする必要があります。そうしないと Vim はどのスクリプトを読み込めばいいのかわ<br>
かりません。<br>
<br>
ライブラリスクリプトをたくさん書く場合は、サブディレクトリを使うといいかもしれ<br>
ません。例:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;netlib#ftp#read('somefile')</div>
<br>
Unix では、このライブラリスクリプトは次のような場所に置かれます:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~/.vim/autoload/netlib/ftp.vim</div>
<br>
関数は次のように定義します:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def netlib#ftp#read(fname: string)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;ftp を使ってファイルを読み込む<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<br>
関数定義と関数呼び出しではまったく同じ名前が使われます。最後の '#' より前の部<br>
分がサブディレクトリとスクリプトの名前に対応しています。<br>
<br>
同じ方法で変数を扱うこともできます:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var weekdays = dutch#weekdays</div>
<br>
これによって &quot;autoload/dutch.vim&quot; が読み込まれます。そのスクリプトには例えば次<br>
のようなコードが書かれています:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ 'donderdag', 'vrijdag', 'zaterdag']</div>
<br>
より詳しくは&nbsp;<a class="Identifier" href="eval.html#autoload">autoload</a>&nbsp;を参照してください。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_51.html#51.6" name="51.6">51.6</a>&nbsp;&nbsp;Vim script を配布する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_51.html#distribute-script" name="distribute-script">distribute-script</a><br>
<br>
Vim ユーザーは Vim のウェブサイト&nbsp;<span class="Constant"><a href="http://www.vim.org">http://www.vim.org</a></span>&nbsp;でスクリプトを探します。<br>
便利なスクリプトを作ったら、ぜひ共有しましょう！<br>
<br>
別の場所として github があります。しかし、そこが探される場所であるとあなたは知<br>
る必要があります!。多くのプラグインマネージャーがプラグインを github から取得<br>
するというアドバンテージがあります。あなたが使うであろうお気に入りのサーチエン<br>
ジンが見付けるのもそこになります。<br>
<br>
Vim script はどのシステムでも使えます。しかしながら tar や gzip コマンドは存在<br>
しないことがあります。ファイルをまとめたり圧縮したりするには &quot;zip&quot; ユーティリ<br>
ティが推奨されています。<br>
<br>
可搬性を最大限に高めるには、Vim 自身を使ってスクリプトをパッケージ化します。そ<br>
れには Vimball ユーティリティを使います。<a class="Identifier" href="pi_vimball.html#vimball">vimball</a>&nbsp;を参照。<br>
<br>
自動更新するための行を書いておくと便利です。<a class="Identifier" href="pi_getscript.html#glvs-plugins">glvs-plugins</a>&nbsp;を参照。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<br>
次章:&nbsp;<a class="Identifier" href="usr_52.html">usr_52.txt</a>&nbsp;&nbsp;Vim9 script でプラグインを作る<br>
<br>
Copyright: see&nbsp;<a class="Identifier" href="usr_01.html#manual-copyright">manual-copyright</a>&nbsp;&nbsp;vim:tw=78:ts=8:noet:ft=help:norl:<br>
</div>
